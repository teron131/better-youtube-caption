{
  "version": 3,
  "sources": ["../src/constants.js", "../src/utils/logger.js", "../src/storage.js", "../src/url.js", "../src/utils/contextValidation.js", "../src/utils/autoGeneration.js", "../src/utils/modelSelection.js", "../src/utils/subtitleRenderer.js", "../src/content.js"],
  "sourcesContent": ["// Constants for Better YouTube Caption Extension\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  SCRAPE_CREATORS_API_KEY: \"scrapeCreatorsApiKey\",\n  OPENROUTER_API_KEY: \"openRouterApiKey\",\n  SUMMARIZER_RECOMMENDED_MODEL: \"summarizerRecommendedModel\",\n  SUMMARIZER_CUSTOM_MODEL: \"summarizerCustomModel\",\n  REFINER_RECOMMENDED_MODEL: \"refinerRecommendedModel\",\n  REFINER_CUSTOM_MODEL: \"refinerCustomModel\",\n  AUTO_GENERATE: \"autoGenerate\",\n  SHOW_SUBTITLES: \"showSubtitles\",\n  CAPTION_FONT_SIZE: \"captionFontSize\",\n  SUMMARY_FONT_SIZE: \"summaryFontSize\",\n  TARGET_LANGUAGE_RECOMMENDED: \"targetLanguageRecommended\",\n  TARGET_LANGUAGE_CUSTOM: \"targetLanguageCustom\",\n};\n\n// Timing constants\nexport const TIMING = {\n  AUTO_GENERATION_DELAY_MS: 2000, // 2 seconds delay before auto-generation\n  INIT_RETRY_DELAY_MS: 500, // Delay between initialization retries\n  SUBTITLE_UPDATE_INTERVAL_MS: 100, // How often to update subtitle display\n  MAX_INIT_ATTEMPTS: 5, // Maximum retry attempts for finding video elements\n  CONTENT_SCRIPT_INIT_DELAY_MS: 500, // Delay for content script initialization\n  STATUS_MESSAGE_DISPLAY_MS: 2000, // How long to display status messages\n  SUMMARY_SUCCESS_DISPLAY_MS: 3000, // How long to display summary success message\n  CAPTION_CHECK_DELAY_MS: 500, // Delay before checking caption availability\n};\n\n// Storage constants\nexport const STORAGE = {\n  QUOTA_BYTES: 10 * 1024 * 1024, // 10MB Chrome storage limit\n  MAX_STORAGE_BYTES: 9.5 * 1024 * 1024, // 9.5MB - leave 0.5MB buffer\n  ESTIMATED_VIDEO_SIZE_BYTES: 30 * 1024, // Estimated ~30KB per video transcript\n  CLEANUP_BATCH_SIZE: 10, // Number of videos to remove during cleanup\n};\n\n// New separate lists for summarizer and refiner\nexport const RECOMMENDED_SUMMARIZER_MODELS = [\n  { value: \"x-ai/grok-4.1-fast\", label: \"Grok 4.1 Fast\" },\n  { value: \"x-ai/grok-4\", label: \"Grok 4\" },\n  { value: \"google/gemini-2.5-flash\", label: \"Gemini 2.5 Flash\" },\n  { value: \"google/gemini-3-pro-preview\", label: \"Gemini 3 Pro\" },\n  { value: \"openai/gpt-5-mini\", label: \"GPT-5 Mini\" },\n  { value: \"openai/gpt-5.1\", label: \"GPT-5.1\" },\n  { value: \"anthropic/claude-haiku-4.5\", label: \"Claude Haiku 4.5\" },\n  { value: \"anthropic/claude-sonnet-4.5\", label: \"Claude Sonnet 4.5\" },\n];\n\nexport const RECOMMENDED_REFINER_MODELS = [\n  { value: \"google/gemini-2.5-flash-lite-preview-09-2025\", label: \"Gemini 2.5 Flash Lite\" },\n  { value: \"x-ai/grok-4.1-fast\", label: \"Grok 4.1 Fast\" },\n];\n\n// Target language options for summarization\nexport const TARGET_LANGUAGES = [\n  { value: \"auto\", label: \"\uD83C\uDF10 Auto\" },\n  { value: \"en\", label: \"\uD83C\uDDFA\uD83C\uDDF8 English\" },\n  { value: \"zh-TW\", label: \"\uD83C\uDDED\uD83C\uDDF0 Chinese\" },\n];\n\n// Default values\nexport const DEFAULTS = {\n  MODEL_SUMMARIZER: \"x-ai/grok-4.1-fast\",\n  MODEL_REFINER: \"google/gemini-2.5-flash-lite-preview-09-2025\",\n  AUTO_GENERATE: false,\n  SHOW_SUBTITLES: true, // Subtitles shown by default\n  CAPTION_FONT_SIZE: \"M\", // Medium\n  SUMMARY_FONT_SIZE: \"M\", // Medium\n  TARGET_LANGUAGE_RECOMMENDED: \"auto\", // Auto-detect language\n  TARGET_LANGUAGE_CUSTOM: \"\", // Custom language code\n};\n\n// Font size mappings\nexport const FONT_SIZES = {\n  CAPTION: {\n    S: { base: \"1.4vw\", max: \"22px\", min: \"12px\", fullscreen: \"1.7vw\", fullscreenMax: \"28px\" },\n    M: { base: \"1.8vw\", max: \"28px\", min: \"14px\", fullscreen: \"2.2vw\", fullscreenMax: \"36px\" },\n    L: { base: \"2.2vw\", max: \"34px\", min: \"16px\", fullscreen: \"2.7vw\", fullscreenMax: \"44px\" },\n  },\n  SUMMARY: {\n    S: { base: \"13px\", h2: \"17px\", h3: \"15px\" },\n    M: { base: \"15px\", h2: \"20px\", h3: \"17px\" },\n    L: { base: \"17px\", h2: \"23px\", h3: \"19px\" },\n  },\n};\n\n// API endpoints\nexport const API_ENDPOINTS = {\n  SCRAPE_CREATORS: \"https://api.scrapecreators.com/v1/youtube/video\",\n  OPENROUTER: \"https://openrouter.ai/api/v1/chat/completions\",\n};\n\n// YouTube-specific constants\nexport const YOUTUBE = {\n  VIDEO_ID_LENGTH: 11, // Standard YouTube video ID length\n  SELECTORS: {\n    VIDEO_PLAYER: \"video.html5-main-video\",\n    MOVIE_PLAYER: \"#movie_player\",\n    VIDEO_CONTAINER: \".html5-video-container\",\n  },\n};\n\n// Message actions\nexport const MESSAGE_ACTIONS = {\n  FETCH_SUBTITLES: \"fetchSubtitles\",\n  GENERATE_SUBTITLES: \"generateSubtitles\",\n  GENERATE_SUMMARY: \"generateSummary\",\n  SUBTITLES_GENERATED: \"subtitlesGenerated\",\n  SUMMARY_GENERATED: \"summaryGenerated\",\n  UPDATE_POPUP_STATUS: \"updatePopupStatus\",\n  TOGGLE_SUBTITLES: \"toggleSubtitles\",\n  GET_VIDEO_TITLE: \"getVideoTitle\",\n  SHOW_ERROR: \"showError\",\n  UPDATE_CAPTION_FONT_SIZE: \"updateCaptionFontSize\",\n};\n\n// Element IDs\nexport const ELEMENT_IDS = {\n  SUBTITLE_CONTAINER: \"youtube-gemini-subtitles-container\",\n  SUBTITLE_TEXT: \"youtube-gemini-subtitles-text\",\n};\n\nexport const REFINER_CONFIG = {\n  MAX_SEGMENTS_PER_CHUNK: 30,\n  CHUNK_SENTINEL: \"<<<__CHUNK_END__>>>\",\n};\n\n// Error messages\nexport const ERROR_MESSAGES = {\n  CONTEXT_INVALIDATED: \"Extension context invalidated\",\n  VIDEO_ID_REQUIRED: \"Video ID is required.\",\n  NO_VIDEO_ID: \"Could not extract video ID from URL.\",\n  NO_TRANSCRIPT: \"No transcript available for this video\",\n  SCRAPE_KEY_MISSING: \"Scrape Creators API key not found. Please set it in settings.\",\n  OPENROUTER_KEY_MISSING: \"OpenRouter API key not found\",\n  NOT_YOUTUBE_PAGE: \"Not a YouTube video page\",\n  SUMMARY_IN_PROGRESS: \"Summary generation is already in progress for this video.\",\n};\n\n// Segment parser configuration\nexport const SEGMENT_PARSER_CONFIG = {\n  GAP_PENALTY: -0.30,\n  TAIL_GUARD_SIZE: 5,\n  LENGTH_TOLERANCE: 0.10,\n};\n\n// Storage cleanup configuration\nexport const STORAGE_CLEANUP = {\n  MIN_VIDEOS_TO_KEEP: 5,\n  DEFAULT_BATCH_SIZE: 10,\n};\n", "/**\n * Lightweight logger shared by content/sidepanel/background.\n * Prefixes logs and can be toggled via DEBUG flag.\n */\n\nconst PREFIX = 'Better YouTube Caption:';\nlet DEBUG = true;\n\nexport const log = (...args) => {\n  if (!DEBUG) return;\n  console.log(PREFIX, ...args);\n};\n\nexport const warn = (...args) => {\n  if (!DEBUG) return;\n  console.warn(PREFIX, ...args);\n};\n\nexport const error = (...args) => {\n  console.error(PREFIX, ...args);\n};\n\nexport const setDebug = (enabled) => {\n  DEBUG = !!enabled;\n};\n", "/**\n * Chrome storage management for subtitles and settings\n */\n\nimport { STORAGE, YOUTUBE, STORAGE_CLEANUP } from \"./constants.js\";\nimport { log } from \"./utils/logger.js\";\n\n/**\n * Get subtitles for a video from local storage\n */\nexport function getStoredSubtitles(videoId) {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([videoId], (result) => {\n      resolve(result[videoId] || null);\n    });\n  });\n}\n\n/**\n * Save subtitles for a video to local storage\n * Automatically handles quota exceeded by cleaning old entries\n */\nexport async function saveSubtitles(videoId, subtitles) {\n  try {\n    await chromeStorageSet({ [videoId]: subtitles });\n    console.log(\"Subtitles saved to local storage for video ID:\", videoId);\n  } catch (error) {\n    if (error.message?.includes(\"QUOTA\")) {\n      console.warn(\"Storage quota exceeded, attempting cleanup...\");\n      await cleanupOldSubtitles(STORAGE.CLEANUP_BATCH_SIZE);\n      await chromeStorageSet({ [videoId]: subtitles });\n      console.log(\"Subtitles saved after cleanup for video:\", videoId);\n    } else {\n      throw error;\n    }\n  }\n}\n\n/**\n * Wrapper for chrome.storage.local.set with promise interface\n */\nfunction chromeStorageSet(items) {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set(items, () => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n/**\n * Get storage usage information\n */\nexport function getStorageUsage() {\n  return new Promise((resolve) => {\n    chrome.storage.local.getBytesInUse(null, (bytesInUse) => {\n      resolve({\n        bytesUsed: bytesInUse || 0,\n        bytesAvailable: STORAGE.QUOTA_BYTES - (bytesInUse || 0),\n        percentageUsed: ((bytesInUse || 0) / STORAGE.QUOTA_BYTES) * 100,\n      });\n    });\n  });\n}\n\n/**\n * Clean up old subtitles when storage is full\n * Removes oldest videos while keeping a minimum number\n */\nexport async function cleanupOldSubtitles(countToRemove = 10) {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.get(null, (allItems) => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n        return;\n      }\n\n      const videoKeys = getVideoKeys(allItems);\n      const keysToRemove = selectKeysToRemove(videoKeys, countToRemove);\n\n      chrome.storage.local.remove(keysToRemove, () => {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message));\n        } else {\n          console.log(`Removed ${keysToRemove.length} old video transcripts`);\n          resolve();\n        }\n      });\n    });\n  });\n}\n\n/**\n * Get all video keys from storage items\n */\nfunction getVideoKeys(allItems) {\n  return Object.keys(allItems).filter(\n    key => key.length === YOUTUBE.VIDEO_ID_LENGTH && Array.isArray(allItems[key])\n  );\n}\n\n/**\n * Select which keys to remove during cleanup\n */\nfunction selectKeysToRemove(videoKeys, countToRemove) {\n  const removeCount = videoKeys.length <= countToRemove\n    ? Math.max(1, videoKeys.length - STORAGE_CLEANUP.MIN_VIDEOS_TO_KEEP)\n    : countToRemove;\n\n  return videoKeys.slice(0, removeCount);\n}\n\n/**\n * Proactively check and clean storage if nearing limit\n */\nexport async function ensureStorageSpace() {\n  const usage = await getStorageUsage();\n\n  if (usage.bytesUsed > STORAGE.MAX_STORAGE_BYTES) {\n    console.log(`Storage usage at ${usage.percentageUsed.toFixed(1)}%, cleaning up...`);\n    const videosToRemove = Math.ceil(\n      (usage.bytesUsed - STORAGE.MAX_STORAGE_BYTES) / STORAGE.ESTIMATED_VIDEO_SIZE_BYTES\n    );\n    await cleanupOldSubtitles(videosToRemove);\n  }\n}\n\n/**\n * Get value from storage\n */\nexport function getStorageValue(keyName) {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([keyName], (result) => {\n      resolve(result[keyName] || null);\n    });\n  });\n}\n\n/**\n * Get API key from storage\n */\nexport const getApiKeyFromStorage = getStorageValue;\n\n/**\n * Save value to storage\n */\nexport function setStorageValue(key, value) {\n  return new Promise((resolve, reject) => {\n    chrome.storage.local.set({ [key]: value }, () => {\n      if (chrome.runtime.lastError) {\n        reject(new Error(chrome.runtime.lastError.message));\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\n/**\n * Save setting to storage (synchronous callback-based)\n */\nexport function saveSetting(key, value) {\n  chrome.storage.local.set({ [key]: value }, () => {\n    if (chrome.runtime.lastError) {\n      console.error('Failed to save setting:', key, chrome.runtime.lastError);\n    } else {\n      log('Auto-saved:', key, value);\n    }\n  });\n}\n", "/**\n * URL Utility Functions\n */\n\n/**\n * Extract video ID from YouTube URL\n * @param {string} url - YouTube URL\n * @returns {string|null} Video ID or null\n */\nexport function extractVideoId(url) {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.searchParams.get(\"v\");\n  } catch (e) {\n    console.error(\"Error extracting video ID:\", url, e);\n    return null;\n  }\n}\n\n/**\n * Clean YouTube URL to extract only video ID and essential parameters\n * @param {string} originalUrl - Original YouTube URL\n * @returns {string} Cleaned URL\n */\nexport function cleanYouTubeUrl(originalUrl) {\n  try {\n    const url = new URL(originalUrl);\n    const videoId = url.searchParams.get(\"v\");\n    if (videoId) {\n      return `${url.protocol}//${url.hostname}${url.pathname}?v=${videoId}`;\n    }\n  } catch (e) {\n    console.error(\"Error parsing URL:\", originalUrl, e);\n  }\n  return originalUrl;\n}\n", "/**\n * Extension Context Validation\n * Utilities for checking if extension context is still valid\n */\n\n/**\n * Get extension URL or fallback for non-extension context\n * @returns {string} Extension URL\n */\nexport function getExtensionUrl() {\n  return typeof chrome !== \"undefined\" && chrome.runtime && chrome.runtime.getURL\n    ? chrome.runtime.getURL(\"\")\n    : \"https://github.com/better-youtube-caption\";\n}\n\n/**\n * Check if extension context is valid\n * @returns {boolean} True if context is valid\n */\nexport function isExtensionContextValid() {\n  return (\n    typeof chrome !== \"undefined\" &&\n    !!chrome.runtime &&\n    typeof chrome.runtime.id === \"string\" &&\n    !!chrome.storage &&\n    !!chrome.storage.local\n  );\n}\n\n/**\n * Check if Chrome runtime error indicates context invalidation\n * @param {chrome.runtime.LastError} lastError - Chrome runtime last error\n * @returns {boolean} True if context invalidated\n */\nexport function isContextInvalidated(lastError) {\n  return (\n    lastError?.message?.toLowerCase().includes(\"extension context invalidated\")\n  );\n}\n\n/**\n * Wrap storage callback with context validation\n * @param {Function} callback - Callback to wrap\n * @returns {Function} Wrapped callback\n */\nexport function withContextValidation(callback) {\n  return function (...args) {\n    if (!isExtensionContextValid()) {\n      console.log(\"Extension context invalidated, skipping operation.\");\n      return;\n    }\n    return callback(...args);\n  };\n}\n\n", "/**\n * Auto-Generation Utilities\n * Handles automatic subtitle generation logic\n */\n\nimport { STORAGE_KEYS, TIMING } from \"../constants.js\";\nimport { extractVideoId } from \"../url.js\";\nimport { isExtensionContextValid } from \"./contextValidation.js\";\nimport { log as debugLog } from \"./logger.js\";\n\n// Track which videos have had auto-generation triggered\nconst autoGenerationTriggered = new Set();\n\n/**\n * Check if auto-generation has been triggered for a video\n * @param {string} videoId - Video ID\n * @returns {boolean} True if already triggered\n */\nexport function isAutoGenerationTriggered(videoId) {\n  return autoGenerationTriggered.has(videoId);\n}\n\n/**\n * Mark auto-generation as triggered for a video\n * @param {string} videoId - Video ID\n */\nexport function markAutoGenerationTriggered(videoId) {\n  autoGenerationTriggered.add(videoId);\n}\n\n/**\n * Clear auto-generation trigger for a video\n * @param {string} videoId - Video ID\n */\nexport function clearAutoGenerationTrigger(videoId) {\n  autoGenerationTriggered.delete(videoId);\n}\n\n/**\n * Check if auto-generation conditions are met\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result with settings\n * @param {boolean} showSubtitlesEnabled - Whether subtitles are enabled\n * @param {boolean} checkCaptionsEnabled - Whether to check captions setting\n * @returns {Object} Validation result\n */\nexport function validateAutoGenerationConditions(\n  videoId,\n  storageResult,\n  showSubtitlesEnabled,\n  checkCaptionsEnabled\n) {\n  if (storageResult[STORAGE_KEYS.AUTO_GENERATE] !== true) {\n    debugLog(\"Auto-gen skipped: setting disabled\");\n    return { isValid: false, reason: \"setting disabled\" };\n  }\n\n  if (checkCaptionsEnabled && !showSubtitlesEnabled) {\n    debugLog(\"Auto-gen skipped: captions disabled\");\n    return { isValid: false, reason: \"captions disabled\" };\n  }\n\n  if (!storageResult[STORAGE_KEYS.SCRAPE_CREATORS_API_KEY]) {\n    debugLog(\"Auto-gen skipped: missing Scrape Creators key\");\n    return { isValid: false, reason: \"missing api key\" };\n  }\n\n  if (isAutoGenerationTriggered(videoId)) {\n    debugLog(\"Auto-gen skipped: already triggered for video\", videoId);\n    return { isValid: false, reason: \"already triggered\" };\n  }\n\n  return { isValid: true };\n}\n\n/**\n * Verify video ID hasn't changed\n * @param {string} originalVideoId - Original video ID\n * @returns {boolean} True if video ID is still valid\n */\nfunction verifyVideoIdUnchanged(originalVideoId) {\n  const currentVideoId = extractVideoId(window.location.href);\n  if (currentVideoId !== originalVideoId) {\n    debugLog(\"Auto-gen cancel: video ID changed\", originalVideoId, \"->\", currentVideoId);\n    clearAutoGenerationTrigger(originalVideoId);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Verify captions are still enabled\n * @param {string} videoId - Video ID\n * @returns {Promise<boolean>} True if captions still enabled\n */\nfunction verifyCaptionsStillEnabled(videoId) {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([STORAGE_KEYS.SHOW_SUBTITLES], (checkResult) => {\n      const captionsStillEnabled = checkResult[STORAGE_KEYS.SHOW_SUBTITLES] !== false;\n      if (!captionsStillEnabled) {\n        debugLog(\"Auto-gen cancel: captions disabled\");\n        clearAutoGenerationTrigger(videoId);\n        resolve(false);\n      } else {\n        resolve(true);\n      }\n    });\n  });\n}\n\n/**\n * Execute auto-generation trigger with validation\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result\n * @param {Function} triggerFn - Function to execute trigger\n * @param {boolean} checkCaptionsEnabled - Whether to check captions\n */\nasync function executeAutoGenerationTrigger(\n  videoId,\n  storageResult,\n  triggerFn,\n  checkCaptionsEnabled\n) {\n  if (!verifyVideoIdUnchanged(videoId)) {\n    return;\n  }\n\n  if (checkCaptionsEnabled) {\n    const captionsEnabled = await verifyCaptionsStillEnabled(videoId);\n    if (!captionsEnabled) {\n      return;\n    }\n  }\n\n  triggerFn();\n}\n\n/**\n * Schedule auto-generation with optional delay\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result\n * @param {Function} triggerFn - Function to execute trigger\n * @param {boolean} checkCaptionsEnabled - Whether to check captions\n * @param {boolean} withDelay - Whether to add delay\n */\nexport function scheduleAutoGeneration(\n  videoId,\n  storageResult,\n  triggerFn,\n  checkCaptionsEnabled,\n  withDelay\n) {\n  markAutoGenerationTriggered(videoId);\n\n  debugLog(\n    \"Auto-gen enabled,\",\n    withDelay ? \"waiting for page to load...\" : \"triggering immediately...\",\n    \"videoId:\",\n    videoId\n  );\n\n  const executeTrigger = () => {\n    executeAutoGenerationTrigger(videoId, storageResult, triggerFn, checkCaptionsEnabled);\n  };\n\n  if (withDelay) {\n    setTimeout(() => {\n      if (!isExtensionContextValid()) {\n        debugLog(\"Context invalidated before auto-generation, aborting.\");\n        clearAutoGenerationTrigger(videoId);\n        return;\n      }\n      debugLog(\"Auto-gen delay elapsed; triggering now for\", videoId);\n      executeTrigger();\n    }, TIMING.AUTO_GENERATION_DELAY_MS);\n  } else {\n    executeTrigger();\n  }\n}\n\n", "/**\n * Model Selection Utilities\n * Centralized logic for selecting models with priority: custom > recommended > default\n */\n\nimport { DEFAULTS, STORAGE_KEYS } from \"../constants.js\";\nimport { getStorageValue } from \"../storage.js\";\n\n/**\n * Get model selection with fallback priority\n * Priority: message > custom > recommended > default\n * @param {string} messageModelSelection - Model from message (highest priority)\n * @param {string} customModel - Custom model from storage\n * @param {string} recommendedModel - Recommended model from storage\n * @param {string} defaultModel - Default model\n * @returns {string} Selected model\n */\nexport function getModelSelection(messageModelSelection, customModel, recommendedModel, defaultModel) {\n  return (\n    messageModelSelection ||\n    customModel?.trim() ||\n    recommendedModel?.trim() ||\n    defaultModel\n  );\n}\n\n/**\n * Get summarizer model from storage\n * @param {Object} storageResult - Storage result object\n * @returns {Promise<string>} Selected model\n */\nexport async function getSummarizerModelFromStorage(storageResult = null) {\n  if (storageResult) {\n    const customModel = storageResult[STORAGE_KEYS.SUMMARIZER_CUSTOM_MODEL]?.trim();\n    const recommendedModel = storageResult[STORAGE_KEYS.SUMMARIZER_RECOMMENDED_MODEL]?.trim();\n    return customModel || recommendedModel || DEFAULTS.MODEL_SUMMARIZER;\n  }\n\n  const customModel = await getStorageValue(STORAGE_KEYS.SUMMARIZER_CUSTOM_MODEL);\n  const recommendedModel = await getStorageValue(STORAGE_KEYS.SUMMARIZER_RECOMMENDED_MODEL);\n  return getModelSelection(null, customModel, recommendedModel, DEFAULTS.MODEL_SUMMARIZER);\n}\n\n/**\n * Get refiner model from storage\n * @param {Object} storageResult - Storage result object\n * @returns {Promise<string>} Selected model\n */\nexport async function getRefinerModelFromStorage(storageResult = null) {\n  if (storageResult) {\n    const customModel = storageResult[STORAGE_KEYS.REFINER_CUSTOM_MODEL]?.trim();\n    const recommendedModel = storageResult[STORAGE_KEYS.REFINER_RECOMMENDED_MODEL]?.trim();\n    return customModel || recommendedModel || DEFAULTS.MODEL_REFINER;\n  }\n\n  const customModel = await getStorageValue(STORAGE_KEYS.REFINER_CUSTOM_MODEL);\n  const recommendedModel = await getStorageValue(STORAGE_KEYS.REFINER_RECOMMENDED_MODEL);\n  return getModelSelection(null, customModel, recommendedModel, DEFAULTS.MODEL_REFINER);\n}\n\n/**\n * Get target language from storage\n * @param {Object} storageResult - Storage result object\n * @returns {Promise<string>} Selected target language\n */\nexport async function getTargetLanguageFromStorage(storageResult = null) {\n  if (storageResult) {\n    const customLanguage = storageResult[STORAGE_KEYS.TARGET_LANGUAGE_CUSTOM]?.trim();\n    const recommendedLanguage = storageResult[STORAGE_KEYS.TARGET_LANGUAGE_RECOMMENDED]?.trim();\n    return customLanguage || recommendedLanguage || DEFAULTS.TARGET_LANGUAGE_RECOMMENDED;\n  }\n\n  const customLanguage = await getStorageValue(STORAGE_KEYS.TARGET_LANGUAGE_CUSTOM);\n  const recommendedLanguage = await getStorageValue(STORAGE_KEYS.TARGET_LANGUAGE_RECOMMENDED);\n  return getModelSelection(null, customLanguage, recommendedLanguage, DEFAULTS.TARGET_LANGUAGE_RECOMMENDED);\n}\n\n", "/**\n * Subtitle Renderer Module\n * Handles creation, display, and updates of subtitle elements on the YouTube video player.\n */\n\nimport { ELEMENT_IDS, FONT_SIZES, TIMING, YOUTUBE } from \"../constants.js\";\nimport { log as debugLog, error as logError, warn as logWarn } from \"./logger.js\";\n\nlet subtitleContainer = null;\nlet subtitleText = null;\nlet videoPlayer = null;\nlet videoContainer = null;\nlet checkInterval = null;\n\n/**\n * Find video elements on the YouTube page\n * @returns {boolean} True if video elements found\n */\nexport function findVideoElements() {\n  videoPlayer = document.querySelector(YOUTUBE.SELECTORS.VIDEO_PLAYER);\n  if (!videoPlayer) return false;\n\n  // Try finding a standard container, fallback to player's parent\n  videoContainer =\n    document.querySelector(YOUTUBE.SELECTORS.MOVIE_PLAYER) ||\n    document.querySelector(YOUTUBE.SELECTORS.VIDEO_CONTAINER) ||\n    videoPlayer.parentElement;\n\n  return !!videoContainer;\n}\n\n/**\n * Create subtitle elements and append them to the video container\n */\nexport function createSubtitleElements() {\n  if (document.getElementById(ELEMENT_IDS.SUBTITLE_CONTAINER)) {\n    // If elements exist, just update references\n    subtitleContainer = document.getElementById(ELEMENT_IDS.SUBTITLE_CONTAINER);\n    subtitleText = document.getElementById(ELEMENT_IDS.SUBTITLE_TEXT);\n    return;\n  }\n\n  subtitleContainer = document.createElement(\"div\");\n  subtitleContainer.id = ELEMENT_IDS.SUBTITLE_CONTAINER;\n  subtitleContainer.style.position = \"absolute\";\n  subtitleContainer.style.zIndex = \"9999\";\n  subtitleContainer.style.pointerEvents = \"none\";\n  subtitleContainer.style.display = \"none\";\n\n  subtitleText = document.createElement(\"div\");\n  subtitleText.id = ELEMENT_IDS.SUBTITLE_TEXT;\n  subtitleContainer.appendChild(subtitleText);\n\n  if (videoContainer) {\n    if (getComputedStyle(videoContainer).position === \"static\") {\n      videoContainer.style.position = \"relative\";\n    }\n    videoContainer.appendChild(subtitleContainer);\n    debugLog(\"Subtitle container added to video container.\");\n  } else {\n    logError(\"Cannot add subtitle container, video container not found.\");\n  }\n}\n\n/**\n * Apply caption font size\n * @param {string} size - Size key (S, M, L)\n */\nexport function applyCaptionFontSize(size) {\n  const sizeConfig = FONT_SIZES.CAPTION[size] || FONT_SIZES.CAPTION.M;\n  \n  // Update CSS custom properties for consistency\n  document.documentElement.style.setProperty(\"--caption-font-size-base\", sizeConfig.base);\n  document.documentElement.style.setProperty(\"--caption-font-size-max\", sizeConfig.max);\n  document.documentElement.style.setProperty(\"--caption-font-size-min\", sizeConfig.min);\n  document.documentElement.style.setProperty(\"--caption-font-size-fullscreen\", sizeConfig.fullscreen);\n  document.documentElement.style.setProperty(\"--caption-font-size-fullscreen-max\", sizeConfig.fullscreenMax);\n\n  // Apply to element directly if it exists, using clamp for responsiveness\n  if (subtitleText) {\n    subtitleText.style.fontSize = `clamp(${sizeConfig.min}, ${sizeConfig.base}, ${sizeConfig.max})`;\n  }\n}\n\n/**\n * Update subtitles based on the current video time\n * @param {Array} currentSubtitles - Array of subtitle objects\n */\nfunction updateSubtitlesInternal(currentSubtitles) {\n  if (!videoPlayer || !subtitleText || !subtitleContainer) {\n    return;\n  }\n\n  if (isNaN(videoPlayer.currentTime)) return;\n\n  const currentTime = videoPlayer.currentTime * 1000; // Convert to ms\n  let foundSubtitle = null;\n\n  for (const subtitle of currentSubtitles) {\n    if (currentTime >= subtitle.startTime && currentTime <= subtitle.endTime) {\n      foundSubtitle = subtitle;\n      break;\n    }\n  }\n\n  if (foundSubtitle) {\n    if (subtitleText.textContent !== foundSubtitle.text) {\n      subtitleText.textContent = foundSubtitle.text;\n    }\n    subtitleContainer.style.display = \"block\";\n  } else {\n    hideCurrentSubtitle();\n  }\n}\n\n/**\n * Start displaying subtitles\n * @param {Array} currentSubtitles - Array of subtitle objects\n */\nexport function startSubtitleDisplay(currentSubtitles) {\n  if (!videoPlayer || !subtitleContainer) {\n    logWarn(\"Cannot start subtitle display: Player or container missing.\");\n    return;\n  }\n\n  stopSubtitleDisplay();\n\n  debugLog(\"Starting subtitle display interval.\");\n  \n  // Create a bound function to hold the subtitles closure\n  const updateFn = () => updateSubtitlesInternal(currentSubtitles);\n  \n  checkInterval = setInterval(updateFn, TIMING.SUBTITLE_UPDATE_INTERVAL_MS);\n\n  videoPlayer.addEventListener(\"play\", updateFn);\n  videoPlayer.addEventListener(\"seeked\", updateFn);\n  \n  // Store the function reference on the element to remove it later if needed\n  videoPlayer._subtitleUpdateFn = updateFn;\n}\n\n/**\n * Stop displaying subtitles\n */\nexport function stopSubtitleDisplay() {\n  if (checkInterval) {\n    clearInterval(checkInterval);\n    checkInterval = null;\n    debugLog(\"Stopped subtitle display interval.\");\n  }\n  if (videoPlayer && videoPlayer._subtitleUpdateFn) {\n    videoPlayer.removeEventListener(\"play\", videoPlayer._subtitleUpdateFn);\n    videoPlayer.removeEventListener(\"seeked\", videoPlayer._subtitleUpdateFn);\n    delete videoPlayer._subtitleUpdateFn;\n  }\n}\n\n/**\n * Hide the current subtitle\n */\nexport function hideCurrentSubtitle() {\n  if (subtitleContainer) {\n    subtitleContainer.style.display = \"none\";\n  }\n  if (subtitleText) {\n    subtitleText.textContent = \"\";\n  }\n}\n\nexport function clearRenderer() {\n  stopSubtitleDisplay();\n  hideCurrentSubtitle();\n}\n\n", "/**\n * Content Script for Better YouTube Caption Extension\n * Handles subtitle display, auto-generation, and communication with background script\n */\n\nimport {\n    DEFAULTS,\n    MESSAGE_ACTIONS,\n    STORAGE_KEYS,\n    TIMING,\n} from \"./constants.js\";\nimport { saveSubtitles } from \"./storage.js\";\nimport { extractVideoId } from \"./url.js\";\nimport {\n    clearAutoGenerationTrigger,\n    scheduleAutoGeneration,\n    validateAutoGenerationConditions,\n} from \"./utils/autoGeneration.js\";\nimport { isContextInvalidated, isExtensionContextValid } from \"./utils/contextValidation.js\";\nimport { log as debugLog, error as logError, warn as logWarn } from \"./utils/logger.js\";\nimport { getRefinerModelFromStorage } from \"./utils/modelSelection.js\";\nimport {\n    applyCaptionFontSize,\n    clearRenderer,\n    createSubtitleElements,\n    findVideoElements,\n    startSubtitleDisplay,\n    stopSubtitleDisplay,\n} from \"./utils/subtitleRenderer.js\";\n\n// Global state\nlet currentSubtitles = [];\nlet initAttempts = 0;\nlet currentUrl = window.location.href;\nlet showSubtitlesEnabled = true; // Whether subtitles should be displayed\nlet urlObserver = null; // MutationObserver for URL changes\n\n/**\n * Check if auto-generation should be triggered and trigger it if conditions are met\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result with API keys and settings\n * @param {boolean} checkCaptionsEnabled - Whether to check if captions are enabled\n * @param {boolean} withDelay - Whether to add a delay before triggering (for initial page load)\n */\nasync function checkAndTriggerAutoGeneration(videoId, storageResult, checkCaptionsEnabled = true, withDelay = false) {\n  const validation = validateAutoGenerationConditions(\n    videoId,\n    storageResult,\n    showSubtitlesEnabled,\n    checkCaptionsEnabled\n  );\n\n  if (!validation.isValid) {\n    return false;\n  }\n\n  const modelSelection = await getRefinerModelFromStorage(storageResult);\n  const triggerFn = () => {\n    triggerAutoGeneration(\n      videoId,\n      storageResult[STORAGE_KEYS.SCRAPE_CREATORS_API_KEY],\n      storageResult[STORAGE_KEYS.OPENROUTER_API_KEY],\n      modelSelection\n    );\n  };\n\n  scheduleAutoGeneration(videoId, storageResult, triggerFn, checkCaptionsEnabled, withDelay);\n  return true;\n}\n\n/**\n * Load stored subtitles for the current video from local storage\n * Also checks for auto-generation setting and triggers generation if enabled\n */\nfunction loadStoredSubtitles() {\n  try {\n    if (!isExtensionContextValid()) {\n      logWarn(\"Extension context invalidated, skipping subtitle load.\");\n      return;\n    }\n\n    // Only proceed if we're on a YouTube video page\n    if (!window.location.href.includes(\"youtube.com/watch\")) {\n      debugLog(\"Not on a video page, skipping subtitle load.\");\n      return;\n    }\n\n    const videoId = extractVideoId(window.location.href);\n    if (!videoId) {\n      logWarn(\"Could not extract video ID, skipping subtitle load.\");\n      return;\n    }\n\n    const keysToFetch = [\n      videoId,\n      STORAGE_KEYS.AUTO_GENERATE,\n      STORAGE_KEYS.SCRAPE_CREATORS_API_KEY,\n      STORAGE_KEYS.OPENROUTER_API_KEY,\n      STORAGE_KEYS.REFINER_RECOMMENDED_MODEL,\n      STORAGE_KEYS.REFINER_CUSTOM_MODEL,\n      STORAGE_KEYS.SHOW_SUBTITLES,\n    ];\n\n    chrome.storage.local.get(keysToFetch, (result) => {\n      try {\n        if (chrome.runtime.lastError) {\n          if (isContextInvalidated(chrome.runtime.lastError)) {\n            debugLog(\"Subtitle load aborted - extension context invalidated.\");\n            return;\n          }\n          logError(\"Error loading subtitles from storage:\", chrome.runtime.lastError.message);\n          return;\n        }\n\n        // Update show subtitles setting\n        showSubtitlesEnabled = result[STORAGE_KEYS.SHOW_SUBTITLES] !== false;\n\n        if (result && result[videoId]) {\n          debugLog(\"Found stored subtitles for this video.\");\n          currentSubtitles = result[videoId];\n          if (showSubtitlesEnabled) {\n            startSubtitleDisplay(currentSubtitles);\n          }\n        } else {\n          debugLog(\"No stored subtitles found for this video.\");\n          // Try to trigger auto-generation if conditions are met\n          checkAndTriggerAutoGeneration(videoId, result, true, true);\n        }\n      } catch (error) {\n        logError(\"Error processing stored subtitles:\", error);\n      }\n    });\n  } catch (error) {\n    if (error?.message?.includes(\"Extension context invalidated\")) {\n      debugLog(\"Subtitle load aborted - extension context invalidated (outer).\");\n      return;\n    }\n    logError(\"Error in loadStoredSubtitles:\", error);\n  }\n}\n\n/**\n * Trigger automatic subtitle generation\n * @param {string} videoId - Video ID\n * @param {string} scrapeCreatorsApiKey - Scrape Creators API key\n * @param {string} openRouterApiKey - OpenRouter API key\n * @param {string} modelSelection - Model selection\n */\nfunction triggerAutoGeneration(videoId, scrapeCreatorsApiKey, openRouterApiKey, modelSelection) {\n  clearSubtitles();\n\n  debugLog(\"Sending fetchSubtitles message to background...\", {\n    action: MESSAGE_ACTIONS.FETCH_SUBTITLES,\n    videoId: videoId,\n    hasScrapeKey: !!scrapeCreatorsApiKey,\n    hasOpenRouterKey: !!openRouterApiKey,\n    modelSelection: modelSelection,\n  });\n\n  chrome.runtime.sendMessage(\n    {\n      action: MESSAGE_ACTIONS.FETCH_SUBTITLES,\n      videoId: videoId,\n      scrapeCreatorsApiKey: scrapeCreatorsApiKey,\n      openRouterApiKey: openRouterApiKey,\n      modelSelection: modelSelection,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        logError(\"Error triggering auto-generation:\", chrome.runtime.lastError.message);\n        clearAutoGenerationTrigger(videoId);\n      } else {\n        debugLog(\"Auto-generation triggered successfully, response:\", response);\n      }\n    }\n  );\n}\n\n/**\n * Monitor URL changes on YouTube (SPA behavior)\n */\nfunction monitorUrlChanges() {\n  // Disconnect existing observer if any\n  if (urlObserver) {\n    urlObserver.disconnect();\n    urlObserver = null;\n  }\n\n  urlObserver = new MutationObserver(() => {\n    // Stop monitoring if extension context is invalidated\n    if (!isExtensionContextValid()) {\n      if (urlObserver) {\n        urlObserver.disconnect();\n        urlObserver = null;\n      }\n      return;\n    }\n\n    if (currentUrl !== window.location.href) {\n      debugLog(\"URL changed (mutation).\");\n      const oldVideoId = extractVideoId(currentUrl);\n      currentUrl = window.location.href;\n      const newVideoId = extractVideoId(currentUrl);\n\n      // If video ID changed, clear the auto-generation tracking for the old video\n      if (oldVideoId !== newVideoId) {\n        clearAutoGenerationTrigger(oldVideoId);\n      }\n\n      onUrlChange();\n    }\n  });\n\n  urlObserver.observe(document.body, { childList: true, subtree: true });\n}\n\n/**\n * Handle actions when the URL changes\n */\nfunction onUrlChange() {\n  debugLog(\"Reinitializing for new video...\");\n  clearSubtitles();\n  initAttempts = 0;\n  initialize();\n}\n\n/**\n * Initialize the content script\n */\nfunction initialize() {\n  debugLog(\"Initializing content script...\");\n\n  // Only initialize on YouTube video pages\n  if (!window.location.href.includes(\"youtube.com/watch\")) {\n    debugLog(\"Not on a video page, skipping initialization.\");\n    return;\n  }\n\n  if (!findVideoElements()) {\n    initAttempts++;\n    if (initAttempts < TIMING.MAX_INIT_ATTEMPTS) {\n      debugLog(`Video player not found, retrying (${initAttempts}/${TIMING.MAX_INIT_ATTEMPTS})...`);\n      setTimeout(initialize, TIMING.INIT_RETRY_DELAY_MS);\n    } else {\n      logError(\"Video player or container not found after multiple attempts.\");\n    }\n    return;\n  }\n\n  debugLog(\"Video player found.\");\n\n  createSubtitleElements();\n  loadStoredSubtitles();\n  loadCaptionFontSize();\n  setupMessageListener();\n}\n\n/**\n * Setup message listener for content script\n */\nfunction setupMessageListener() {\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === MESSAGE_ACTIONS.GET_VIDEO_TITLE) {\n      handleGetVideoTitle(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.GENERATE_SUMMARY) {\n      handleGenerateSummary(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.GENERATE_SUBTITLES) {\n      handleGenerateSubtitles(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.SUBTITLES_GENERATED) {\n      handleSubtitlesGenerated(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.TOGGLE_SUBTITLES) {\n      handleToggleSubtitles(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.UPDATE_CAPTION_FONT_SIZE) {\n      handleUpdateCaptionFontSize(message, sendResponse);\n      return true;\n    }\n  });\n}\n\n/**\n * Handle get video title request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleGetVideoTitle(message, sendResponse) {\n  const titleElement = document.querySelector(\"h1.ytd-watch-metadata yt-formatted-string\");\n  const title = titleElement ? titleElement.textContent : null;\n  sendResponse({ title: title });\n}\n\n/**\n * Handle generate summary request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleGenerateSummary(message, sendResponse) {\n  debugLog(\"Received generateSummary request\");\n\n  const videoId = message.videoId || extractVideoId(window.location.href);\n\n  if (!videoId) {\n    sendResponse({\n      status: \"error\",\n      message: \"Could not extract video ID from URL.\",\n    });\n    return;\n  }\n\n  debugLog(\"Requesting summary from background for video:\", videoId);\n\n  chrome.runtime.sendMessage(\n    {\n      action: MESSAGE_ACTIONS.GENERATE_SUMMARY,\n      videoId: videoId,\n      scrapeCreatorsApiKey: message.scrapeCreatorsApiKey,\n      openRouterApiKey: message.openRouterApiKey,\n      modelSelection: message.modelSelection,\n      targetLanguage: message.targetLanguage,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        logError(\"Error sending message to background:\", chrome.runtime.lastError);\n        sendResponse({\n          status: \"error\",\n          message: \"Could not communicate with background script.\",\n        });\n      } else {\n        debugLog(\"Summary request sent to background, response:\", response);\n      }\n    }\n  );\n\n  sendResponse({ status: \"started\" });\n}\n\n/**\n * Handle generate subtitles request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleGenerateSubtitles(message, sendResponse) {\n  debugLog(\"Received generateSubtitles request\");\n\n  const videoId = message.videoId || extractVideoId(window.location.href);\n\n  if (!videoId) {\n    sendResponse({\n      status: \"error\",\n      message: \"Could not extract video ID from URL.\",\n    });\n    return;\n  }\n\n  debugLog(\"Sending video ID to background:\", videoId);\n\n  clearSubtitles();\n\n  chrome.runtime.sendMessage(\n    {\n      action: MESSAGE_ACTIONS.FETCH_SUBTITLES,\n      videoId: videoId,\n      scrapeCreatorsApiKey: message.scrapeCreatorsApiKey,\n      openRouterApiKey: message.openRouterApiKey,\n      modelSelection: message.modelSelection,\n      forceRegenerate: message.forceRegenerate === true,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        logError(\"Error sending message to background:\", chrome.runtime.lastError);\n        sendResponse({\n          status: \"error\",\n          message: \"Could not communicate with background script.\",\n        });\n      } else {\n        debugLog(\"Message sent to background, response:\", response);\n        if (response?.status === \"error\") {\n          clearAutoGenerationTrigger(videoId);\n        }\n      }\n    }\n  );\n\n  sendResponse({ status: \"started\" });\n}\n\n/**\n * Handle subtitles generated message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleSubtitlesGenerated(message, sendResponse) {\n  debugLog(\"Received subtitlesGenerated request\");\n  currentSubtitles = message.subtitles || [];\n  debugLog(`Received ${currentSubtitles.length} subtitle entries.`);\n\n  if (currentSubtitles.length > 0) {\n    if (showSubtitlesEnabled) {\n      startSubtitleDisplay(currentSubtitles);\n    }\n\n    // Store the subtitles locally\n    const videoId = message.videoId || extractVideoId(window.location.href);\n\n    if (videoId) {\n      saveSubtitles(videoId, currentSubtitles).catch(error => {\n        logError(\"Error saving subtitles:\", error);\n      });\n    } else {\n      logWarn(\"Could not extract video ID, subtitles not saved.\");\n    }\n\n    sendResponse({ status: \"success\" });\n  } else {\n    logWarn(\"Received empty subtitles array.\");\n    clearSubtitles();\n    sendResponse({ status: \"no_subtitles_found\" });\n  }\n}\n\n/**\n * Load and apply caption font size from storage\n */\nfunction loadCaptionFontSize() {\n  try {\n    if (!isExtensionContextValid()) {\n      debugLog(\"Context invalidated, skipping font size load.\");\n      return;\n    }\n\n    chrome.storage.local.get([STORAGE_KEYS.CAPTION_FONT_SIZE], (result) => {\n      try {\n        if (chrome.runtime.lastError) {\n          const errorMsg = chrome.runtime.lastError.message || \"\";\n          if (isContextInvalidated(chrome.runtime.lastError)) {\n            debugLog(\"Font size load aborted - extension context invalidated.\");\n            return;\n          }\n          logWarn(\"Error loading caption font size:\", errorMsg);\n          return;\n        }\n\n        const fontSize = result?.[STORAGE_KEYS.CAPTION_FONT_SIZE] || DEFAULTS.CAPTION_FONT_SIZE;\n        applyCaptionFontSize(fontSize);\n      } catch (error) {\n        if (error?.message?.includes(\"Extension context invalidated\")) {\n          debugLog(\"Font size load aborted (callback) - extension context invalidated.\");\n          return;\n        }\n        logError(\"Error applying caption font size:\", error);\n      }\n    });\n  } catch (error) {\n    if (error?.message?.includes(\"Extension context invalidated\")) {\n      debugLog(\"Font size load aborted (outer) - extension context invalidated.\");\n      return;\n    }\n    logError(\"Error in loadCaptionFontSize:\", error);\n  }\n}\n\n/**\n * Handle update caption font size message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleUpdateCaptionFontSize(message, sendResponse) {\n  const fontSize = message.fontSize || DEFAULTS.CAPTION_FONT_SIZE;\n  applyCaptionFontSize(fontSize);\n  sendResponse({ status: \"success\" });\n}\n\n/**\n * Handle toggle subtitles message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleToggleSubtitles(message, sendResponse) {\n  debugLog(\"Received toggleSubtitles request\");\n  const hasShowSubtitles = Object.prototype.hasOwnProperty.call(message, \"showSubtitles\");\n  const hasEnabled = Object.prototype.hasOwnProperty.call(message, \"enabled\");\n  const nextState = hasShowSubtitles\n    ? message.showSubtitles !== false\n    : hasEnabled\n    ? message.enabled !== false\n    : true;\n  const wasEnabled = showSubtitlesEnabled;\n  showSubtitlesEnabled = nextState;\n  chrome.storage.local.set({ [STORAGE_KEYS.SHOW_SUBTITLES]: showSubtitlesEnabled });\n\n  if (showSubtitlesEnabled && currentSubtitles.length > 0) {\n    startSubtitleDisplay(currentSubtitles);\n  } else {\n    stopSubtitleDisplay();\n    clearRenderer();\n  }\n\n  // If captions were just turned on and there are no subtitles, check for auto-generation\n  if (showSubtitlesEnabled && !wasEnabled && currentSubtitles.length === 0) {\n    const videoId = extractVideoId(window.location.href);\n    if (videoId) {\n      chrome.storage.local.get(\n        [\n          videoId,\n          STORAGE_KEYS.AUTO_GENERATE,\n          STORAGE_KEYS.SCRAPE_CREATORS_API_KEY,\n          STORAGE_KEYS.OPENROUTER_API_KEY,\n          STORAGE_KEYS.REFINER_RECOMMENDED_MODEL,\n          STORAGE_KEYS.REFINER_CUSTOM_MODEL,\n        ],\n        (result) => {\n          // Check if subtitles already exist for this video\n          if (result[videoId] && result[videoId].length > 0) {\n            debugLog(\"Subtitles already exist for this video, loading them...\");\n            currentSubtitles = result[videoId];\n            startSubtitleDisplay(currentSubtitles);\n            return;\n          }\n\n          // Try to trigger auto-generation (no delay, captions already enabled)\n          checkAndTriggerAutoGeneration(videoId, result, false, false);\n        }\n      );\n    }\n  }\n\n  sendResponse({ status: \"success\" });\n}\n\n/**\n * Clear subtitles and stop display\n */\nfunction clearSubtitles() {\n  currentSubtitles = [];\n  clearRenderer();\n  debugLog(\"Subtitles cleared.\");\n}\n\n// Initialize immediately since we're using document_end in manifest\n(function () {\n  debugLog(\"Content script loaded, readyState:\", document.readyState);\n\n  const startInitialization = () => {\n    initialize();\n    monitorUrlChanges();\n  };\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", startInitialization);\n  } else {\n    // Give YouTube a moment to render if we're already loaded\n    setTimeout(startInitialization, TIMING.CONTENT_SCRIPT_INIT_DELAY_MS);\n  }\n})();\n"],
  "mappings": "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",
  "names": ["STORAGE_KEYS", "TIMING", "STORAGE", "DEFAULTS", "FONT_SIZES", "YOUTUBE", "MESSAGE_ACTIONS", "ELEMENT_IDS", "STORAGE_CLEANUP", "PREFIX", "DEBUG", "log", "args", "warn", "error", "saveSubtitles", "videoId", "subtitles", "chromeStorageSet", "error", "cleanupOldSubtitles", "STORAGE", "items", "resolve", "reject", "cleanupOldSubtitles", "countToRemove", "resolve", "reject", "allItems", "videoKeys", "getVideoKeys", "keysToRemove", "selectKeysToRemove", "key", "YOUTUBE", "removeCount", "STORAGE_CLEANUP", "getStorageValue", "keyName", "resolve", "result", "extractVideoId", "url", "e", "isExtensionContextValid", "isContextInvalidated", "lastError", "autoGenerationTriggered", "isAutoGenerationTriggered", "videoId", "markAutoGenerationTriggered", "clearAutoGenerationTrigger", "validateAutoGenerationConditions", "storageResult", "showSubtitlesEnabled", "checkCaptionsEnabled", "STORAGE_KEYS", "log", "verifyVideoIdUnchanged", "originalVideoId", "currentVideoId", "extractVideoId", "verifyCaptionsStillEnabled", "resolve", "checkResult", "executeAutoGenerationTrigger", "triggerFn", "scheduleAutoGeneration", "withDelay", "executeTrigger", "isExtensionContextValid", "TIMING", "getModelSelection", "messageModelSelection", "customModel", "recommendedModel", "defaultModel", "getRefinerModelFromStorage", "storageResult", "customModel", "STORAGE_KEYS", "recommendedModel", "DEFAULTS", "getStorageValue", "getModelSelection", "subtitleContainer", "subtitleText", "videoPlayer", "videoContainer", "checkInterval", "findVideoElements", "YOUTUBE", "createSubtitleElements", "ELEMENT_IDS", "log", "error", "applyCaptionFontSize", "size", "sizeConfig", "FONT_SIZES", "updateSubtitlesInternal", "currentSubtitles", "currentTime", "foundSubtitle", "subtitle", "hideCurrentSubtitle", "startSubtitleDisplay", "warn", "stopSubtitleDisplay", "updateFn", "TIMING", "clearRenderer", "currentSubtitles", "initAttempts", "currentUrl", "showSubtitlesEnabled", "urlObserver", "checkAndTriggerAutoGeneration", "videoId", "storageResult", "checkCaptionsEnabled", "withDelay", "validateAutoGenerationConditions", "modelSelection", "getRefinerModelFromStorage", "scheduleAutoGeneration", "triggerAutoGeneration", "STORAGE_KEYS", "loadStoredSubtitles", "isExtensionContextValid", "warn", "log", "extractVideoId", "keysToFetch", "result", "isContextInvalidated", "error", "startSubtitleDisplay", "scrapeCreatorsApiKey", "openRouterApiKey", "clearSubtitles", "MESSAGE_ACTIONS", "response", "clearAutoGenerationTrigger", "monitorUrlChanges", "oldVideoId", "newVideoId", "onUrlChange", "initialize", "findVideoElements", "TIMING", "createSubtitleElements", "loadCaptionFontSize", "setupMessageListener", "message", "sender", "sendResponse", "handleGetVideoTitle", "handleGenerateSummary", "handleGenerateSubtitles", "handleSubtitlesGenerated", "handleToggleSubtitles", "handleUpdateCaptionFontSize", "titleElement", "title", "saveSubtitles", "errorMsg", "fontSize", "DEFAULTS", "applyCaptionFontSize", "hasShowSubtitles", "hasEnabled", "nextState", "wasEnabled", "stopSubtitleDisplay", "clearRenderer", "startInitialization"]
}
