{
  "version": 3,
  "sources": ["../src/constants.js", "../src/url.js", "../src/utils/contextValidation.js", "../src/utils/logger.js", "../src/utils/autoGeneration.js", "../src/utils/subtitleRenderer.js", "../src/content.js"],
  "sourcesContent": ["// Constants for Better YouTube Caption Extension\n\n// Storage keys\nexport const STORAGE_KEYS = {\n  SCRAPE_CREATORS_API_KEY: \"scrapeCreatorsApiKey\",\n  OPENROUTER_API_KEY: \"openRouterApiKey\",\n  SUMMARIZER_RECOMMENDED_MODEL: \"summarizerRecommendedModel\",\n  SUMMARIZER_CUSTOM_MODEL: \"summarizerCustomModel\",\n  REFINER_RECOMMENDED_MODEL: \"refinerRecommendedModel\",\n  REFINER_CUSTOM_MODEL: \"refinerCustomModel\",\n  AUTO_GENERATE: \"autoGenerate\",\n  SHOW_SUBTITLES: \"showSubtitles\",\n  CAPTION_FONT_SIZE: \"captionFontSize\",\n  SUMMARY_FONT_SIZE: \"summaryFontSize\",\n  TARGET_LANGUAGE_RECOMMENDED: \"targetLanguageRecommended\",\n  TARGET_LANGUAGE_CUSTOM: \"targetLanguageCustom\",\n};\n\n// Timing constants\nexport const TIMING = {\n  AUTO_GENERATION_DELAY_MS: 2000, // 2 seconds delay before auto-generation\n  INIT_RETRY_DELAY_MS: 500, // Delay between initialization retries\n  SUBTITLE_UPDATE_INTERVAL_MS: 100, // How often to update subtitle display\n  MAX_INIT_ATTEMPTS: 5, // Maximum retry attempts for finding video elements\n  CONTENT_SCRIPT_INIT_DELAY_MS: 500, // Delay for content script initialization\n  STATUS_MESSAGE_DISPLAY_MS: 2000, // How long to display status messages\n  SUMMARY_SUCCESS_DISPLAY_MS: 3000, // How long to display summary success message\n  CAPTION_CHECK_DELAY_MS: 500, // Delay before checking caption availability\n};\n\n// Storage constants\nexport const STORAGE = {\n  QUOTA_BYTES: 10 * 1024 * 1024, // 10MB Chrome storage limit\n  MAX_STORAGE_BYTES: 9.5 * 1024 * 1024, // 9.5MB - leave 0.5MB buffer\n  ESTIMATED_VIDEO_SIZE_BYTES: 30 * 1024, // Estimated ~30KB per video transcript\n  CLEANUP_BATCH_SIZE: 10, // Number of videos to remove during cleanup\n};\n\n// New separate lists for summarizer and refiner\nexport const RECOMMENDED_SUMMARIZER_MODELS = [\n  { value: \"x-ai/grok-4.1-fast\", label: \"Grok 4.1 Fast\" },\n  { value: \"x-ai/grok-4\", label: \"Grok 4\" },\n  { value: \"google/gemini-2.5-flash\", label: \"Gemini 2.5 Flash\" },\n  { value: \"google/gemini-3-pro-preview\", label: \"Gemini 3 Pro\" },\n  { value: \"openai/gpt-5-mini\", label: \"GPT-5 Mini\" },\n  { value: \"openai/gpt-5.1\", label: \"GPT-5.1\" },\n  { value: \"anthropic/claude-haiku-4.5\", label: \"Claude Haiku 4.5\" },\n  { value: \"anthropic/claude-sonnet-4.5\", label: \"Claude Sonnet 4.5\" },\n];\n\nexport const RECOMMENDED_REFINER_MODELS = [\n  { value: \"google/gemini-2.5-flash-lite-preview-09-2025\", label: \"Gemini 2.5 Flash Lite\" },\n  { value: \"x-ai/grok-4.1-fast\", label: \"Grok 4.1 Fast\" },\n];\n\n// Target language options for summarization\nexport const TARGET_LANGUAGES = [\n  { value: \"auto\", label: \"\uD83C\uDF10 Auto\" },\n  { value: \"en\", label: \"\uD83C\uDDFA\uD83C\uDDF8 English\" },\n  { value: \"zh-TW\", label: \"\uD83C\uDDED\uD83C\uDDF0 Chinese\" },\n];\n\n// Default values\nexport const DEFAULTS = {\n  MODEL_SUMMARIZER: \"x-ai/grok-4.1-fast\",\n  MODEL_REFINER: \"google/gemini-2.5-flash-lite-preview-09-2025\",\n  AUTO_GENERATE: false,\n  SHOW_SUBTITLES: true, // Subtitles shown by default\n  CAPTION_FONT_SIZE: \"M\", // Medium\n  SUMMARY_FONT_SIZE: \"M\", // Medium\n  TARGET_LANGUAGE_RECOMMENDED: \"auto\", // Auto-detect language\n  TARGET_LANGUAGE_CUSTOM: \"\", // Custom language code\n};\n\n// Font size mappings\nexport const FONT_SIZES = {\n  CAPTION: {\n    S: { base: \"1.4vw\", max: \"22px\", min: \"12px\", fullscreen: \"1.7vw\", fullscreenMax: \"28px\" },\n    M: { base: \"1.8vw\", max: \"28px\", min: \"14px\", fullscreen: \"2.2vw\", fullscreenMax: \"36px\" },\n    L: { base: \"2.2vw\", max: \"34px\", min: \"16px\", fullscreen: \"2.7vw\", fullscreenMax: \"44px\" },\n  },\n  SUMMARY: {\n    S: { base: \"13px\", h2: \"17px\", h3: \"15px\" },\n    M: { base: \"15px\", h2: \"20px\", h3: \"17px\" },\n    L: { base: \"17px\", h2: \"23px\", h3: \"19px\" },\n  },\n};\n\n// API endpoints\nexport const API_ENDPOINTS = {\n  SCRAPE_CREATORS: \"https://api.scrapecreators.com/v1/youtube/video\",\n  OPENROUTER: \"https://openrouter.ai/api/v1/chat/completions\",\n};\n\n// YouTube-specific constants\nexport const YOUTUBE = {\n  VIDEO_ID_LENGTH: 11, // Standard YouTube video ID length\n  SELECTORS: {\n    VIDEO_PLAYER: \"video.html5-main-video\",\n    MOVIE_PLAYER: \"#movie_player\",\n    VIDEO_CONTAINER: \".html5-video-container\",\n  },\n};\n\n// Message actions\nexport const MESSAGE_ACTIONS = {\n  FETCH_SUBTITLES: \"fetchSubtitles\",\n  GENERATE_SUBTITLES: \"generateSubtitles\",\n  GENERATE_SUMMARY: \"generateSummary\",\n  SUBTITLES_GENERATED: \"subtitlesGenerated\",\n  SUMMARY_GENERATED: \"summaryGenerated\",\n  UPDATE_POPUP_STATUS: \"updatePopupStatus\",\n  TOGGLE_SUBTITLES: \"toggleSubtitles\",\n  GET_VIDEO_TITLE: \"getVideoTitle\",\n  SHOW_ERROR: \"showError\",\n  UPDATE_CAPTION_FONT_SIZE: \"updateCaptionFontSize\",\n};\n\n// Element IDs\nexport const ELEMENT_IDS = {\n  SUBTITLE_CONTAINER: \"youtube-gemini-subtitles-container\",\n  SUBTITLE_TEXT: \"youtube-gemini-subtitles-text\",\n};\n\nexport const REFINER_CONFIG = {\n  MAX_SEGMENTS_PER_CHUNK: 30,\n  CHUNK_SENTINEL: \"<<<__CHUNK_END__>>>\",\n};\n\n// Error messages\nexport const ERROR_MESSAGES = {\n  CONTEXT_INVALIDATED: \"Extension context invalidated\",\n  VIDEO_ID_REQUIRED: \"Video ID is required.\",\n  NO_VIDEO_ID: \"Could not extract video ID from URL.\",\n  NO_TRANSCRIPT: \"No transcript available for this video\",\n  SCRAPE_KEY_MISSING: \"Scrape Creators API key not found. Please set it in settings.\",\n  OPENROUTER_KEY_MISSING: \"OpenRouter API key not found\",\n  NOT_YOUTUBE_PAGE: \"Not a YouTube video page\",\n  SUMMARY_IN_PROGRESS: \"Summary generation is already in progress for this video.\",\n};\n", "/**\n * URL Utility Functions\n */\n\n/**\n * Extract video ID from YouTube URL\n * @param {string} url - YouTube URL\n * @returns {string|null} Video ID or null\n */\nexport function extractVideoId(url) {\n  try {\n    const urlObj = new URL(url);\n    return urlObj.searchParams.get(\"v\");\n  } catch (e) {\n    console.error(\"Error extracting video ID:\", url, e);\n    return null;\n  }\n}\n\n/**\n * Clean YouTube URL to extract only video ID and essential parameters\n * @param {string} originalUrl - Original YouTube URL\n * @returns {string} Cleaned URL\n */\nexport function cleanYouTubeUrl(originalUrl) {\n  try {\n    const url = new URL(originalUrl);\n    const videoId = url.searchParams.get(\"v\");\n    if (videoId) {\n      return `${url.protocol}//${url.hostname}${url.pathname}?v=${videoId}`;\n    }\n  } catch (e) {\n    console.error(\"Error parsing URL:\", originalUrl, e);\n  }\n  return originalUrl;\n}\n", "/**\n * Extension Context Validation\n * Utilities for checking if extension context is still valid\n */\n\n/**\n * Check if extension context is valid\n * @returns {boolean} True if context is valid\n */\nexport function isExtensionContextValid() {\n  return (\n    typeof chrome !== \"undefined\" &&\n    !!chrome.runtime &&\n    typeof chrome.runtime.id === \"string\" &&\n    !!chrome.storage &&\n    !!chrome.storage.local\n  );\n}\n\n/**\n * Check if Chrome runtime error indicates context invalidation\n * @param {chrome.runtime.LastError} lastError - Chrome runtime last error\n * @returns {boolean} True if context invalidated\n */\nexport function isContextInvalidated(lastError) {\n  return (\n    lastError?.message?.toLowerCase().includes(\"extension context invalidated\")\n  );\n}\n\n/**\n * Wrap storage callback with context validation\n * @param {Function} callback - Callback to wrap\n * @returns {Function} Wrapped callback\n */\nexport function withContextValidation(callback) {\n  return function (...args) {\n    if (!isExtensionContextValid()) {\n      console.log(\"Extension context invalidated, skipping operation.\");\n      return;\n    }\n    return callback(...args);\n  };\n}\n\n", "/**\n * Lightweight logger shared by content/sidepanel/background.\n * Prefixes logs and can be toggled via DEBUG flag.\n */\n\nconst PREFIX = 'Better YouTube Caption:';\nlet DEBUG = true;\n\nexport const log = (...args) => {\n  if (!DEBUG) return;\n  console.log(PREFIX, ...args);\n};\n\nexport const warn = (...args) => {\n  if (!DEBUG) return;\n  console.warn(PREFIX, ...args);\n};\n\nexport const error = (...args) => {\n  console.error(PREFIX, ...args);\n};\n\nexport const setDebug = (enabled) => {\n  DEBUG = !!enabled;\n};\n", "/**\n * Auto-Generation Utilities\n * Handles automatic subtitle generation logic\n */\n\nimport { STORAGE_KEYS, TIMING } from \"../constants.js\";\nimport { extractVideoId } from \"../url.js\";\nimport { isExtensionContextValid } from \"./contextValidation.js\";\nimport { log as debugLog } from \"./logger.js\";\n\n// Track which videos have had auto-generation triggered\nconst autoGenerationTriggered = new Set();\n\n/**\n * Check if auto-generation has been triggered for a video\n * @param {string} videoId - Video ID\n * @returns {boolean} True if already triggered\n */\nexport function isAutoGenerationTriggered(videoId) {\n  return autoGenerationTriggered.has(videoId);\n}\n\n/**\n * Mark auto-generation as triggered for a video\n * @param {string} videoId - Video ID\n */\nexport function markAutoGenerationTriggered(videoId) {\n  autoGenerationTriggered.add(videoId);\n}\n\n/**\n * Clear auto-generation trigger for a video\n * @param {string} videoId - Video ID\n */\nexport function clearAutoGenerationTrigger(videoId) {\n  autoGenerationTriggered.delete(videoId);\n}\n\n/**\n * Check if auto-generation conditions are met\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result with settings\n * @param {boolean} showSubtitlesEnabled - Whether subtitles are enabled\n * @param {boolean} checkCaptionsEnabled - Whether to check captions setting\n * @returns {Object} Validation result\n */\nexport function validateAutoGenerationConditions(\n  videoId,\n  storageResult,\n  showSubtitlesEnabled,\n  checkCaptionsEnabled\n) {\n  if (storageResult[STORAGE_KEYS.AUTO_GENERATE] !== true) {\n    debugLog(\"Auto-gen skipped: setting disabled\");\n    return { isValid: false, reason: \"setting disabled\" };\n  }\n\n  if (checkCaptionsEnabled && !showSubtitlesEnabled) {\n    debugLog(\"Auto-gen skipped: captions disabled\");\n    return { isValid: false, reason: \"captions disabled\" };\n  }\n\n  if (!storageResult[STORAGE_KEYS.SCRAPE_CREATORS_API_KEY]) {\n    debugLog(\"Auto-gen skipped: missing Scrape Creators key\");\n    return { isValid: false, reason: \"missing api key\" };\n  }\n\n  if (isAutoGenerationTriggered(videoId)) {\n    debugLog(\"Auto-gen skipped: already triggered for video\", videoId);\n    return { isValid: false, reason: \"already triggered\" };\n  }\n\n  return { isValid: true };\n}\n\n/**\n * Verify video ID hasn't changed\n * @param {string} originalVideoId - Original video ID\n * @returns {boolean} True if video ID is still valid\n */\nfunction verifyVideoIdUnchanged(originalVideoId) {\n  const currentVideoId = extractVideoId(window.location.href);\n  if (currentVideoId !== originalVideoId) {\n    debugLog(\"Auto-gen cancel: video ID changed\", originalVideoId, \"->\", currentVideoId);\n    clearAutoGenerationTrigger(originalVideoId);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Verify captions are still enabled\n * @param {string} videoId - Video ID\n * @returns {Promise<boolean>} True if captions still enabled\n */\nfunction verifyCaptionsStillEnabled(videoId) {\n  return new Promise((resolve) => {\n    chrome.storage.local.get([STORAGE_KEYS.SHOW_SUBTITLES], (checkResult) => {\n      const captionsStillEnabled = checkResult[STORAGE_KEYS.SHOW_SUBTITLES] !== false;\n      if (!captionsStillEnabled) {\n        debugLog(\"Auto-gen cancel: captions disabled\");\n        clearAutoGenerationTrigger(videoId);\n        resolve(false);\n      } else {\n        resolve(true);\n      }\n    });\n  });\n}\n\n/**\n * Execute auto-generation trigger with validation\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result\n * @param {Function} triggerFn - Function to execute trigger\n * @param {boolean} checkCaptionsEnabled - Whether to check captions\n */\nasync function executeAutoGenerationTrigger(\n  videoId,\n  storageResult,\n  triggerFn,\n  checkCaptionsEnabled\n) {\n  if (!verifyVideoIdUnchanged(videoId)) {\n    return;\n  }\n\n  if (checkCaptionsEnabled) {\n    const captionsEnabled = await verifyCaptionsStillEnabled(videoId);\n    if (!captionsEnabled) {\n      return;\n    }\n  }\n\n  triggerFn();\n}\n\n/**\n * Schedule auto-generation with optional delay\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result\n * @param {Function} triggerFn - Function to execute trigger\n * @param {boolean} checkCaptionsEnabled - Whether to check captions\n * @param {boolean} withDelay - Whether to add delay\n */\nexport function scheduleAutoGeneration(\n  videoId,\n  storageResult,\n  triggerFn,\n  checkCaptionsEnabled,\n  withDelay\n) {\n  markAutoGenerationTriggered(videoId);\n\n  debugLog(\n    \"Auto-gen enabled,\",\n    withDelay ? \"waiting for page to load...\" : \"triggering immediately...\",\n    \"videoId:\",\n    videoId\n  );\n\n  const executeTrigger = () => {\n    executeAutoGenerationTrigger(videoId, storageResult, triggerFn, checkCaptionsEnabled);\n  };\n\n  if (withDelay) {\n    setTimeout(() => {\n      if (!isExtensionContextValid()) {\n        debugLog(\"Context invalidated before auto-generation, aborting.\");\n        clearAutoGenerationTrigger(videoId);\n        return;\n      }\n      debugLog(\"Auto-gen delay elapsed; triggering now for\", videoId);\n      executeTrigger();\n    }, TIMING.AUTO_GENERATION_DELAY_MS);\n  } else {\n    executeTrigger();\n  }\n}\n\n", "/**\n * Subtitle Renderer Module\n * Handles creation, display, and updates of subtitle elements on the YouTube video player.\n */\n\nimport { ELEMENT_IDS, FONT_SIZES, TIMING, YOUTUBE } from \"../constants.js\";\nimport { log as debugLog, error as logError, warn as logWarn } from \"./logger.js\";\n\nlet subtitleContainer = null;\nlet subtitleText = null;\nlet videoPlayer = null;\nlet videoContainer = null;\nlet checkInterval = null;\n\n/**\n * Find video elements on the YouTube page\n * @returns {boolean} True if video elements found\n */\nexport function findVideoElements() {\n  videoPlayer = document.querySelector(YOUTUBE.SELECTORS.VIDEO_PLAYER);\n  if (!videoPlayer) return false;\n\n  // Try finding a standard container, fallback to player's parent\n  videoContainer =\n    document.querySelector(YOUTUBE.SELECTORS.MOVIE_PLAYER) ||\n    document.querySelector(YOUTUBE.SELECTORS.VIDEO_CONTAINER) ||\n    videoPlayer.parentElement;\n\n  return !!videoContainer;\n}\n\n/**\n * Create subtitle elements and append them to the video container\n */\nexport function createSubtitleElements() {\n  if (document.getElementById(ELEMENT_IDS.SUBTITLE_CONTAINER)) {\n    // If elements exist, just update references\n    subtitleContainer = document.getElementById(ELEMENT_IDS.SUBTITLE_CONTAINER);\n    subtitleText = document.getElementById(ELEMENT_IDS.SUBTITLE_TEXT);\n    return;\n  }\n\n  subtitleContainer = document.createElement(\"div\");\n  subtitleContainer.id = ELEMENT_IDS.SUBTITLE_CONTAINER;\n  subtitleContainer.style.position = \"absolute\";\n  subtitleContainer.style.zIndex = \"9999\";\n  subtitleContainer.style.pointerEvents = \"none\";\n  subtitleContainer.style.display = \"none\";\n\n  subtitleText = document.createElement(\"div\");\n  subtitleText.id = ELEMENT_IDS.SUBTITLE_TEXT;\n  subtitleContainer.appendChild(subtitleText);\n\n  if (videoContainer) {\n    if (getComputedStyle(videoContainer).position === \"static\") {\n      videoContainer.style.position = \"relative\";\n    }\n    videoContainer.appendChild(subtitleContainer);\n    debugLog(\"Subtitle container added to video container.\");\n  } else {\n    logError(\"Cannot add subtitle container, video container not found.\");\n  }\n}\n\n/**\n * Apply caption font size\n * @param {string} size - Size key (S, M, L)\n */\nexport function applyCaptionFontSize(size) {\n  const sizeConfig = FONT_SIZES.CAPTION[size] || FONT_SIZES.CAPTION.M;\n  \n  // Update CSS custom properties for consistency\n  document.documentElement.style.setProperty(\"--caption-font-size-base\", sizeConfig.base);\n  document.documentElement.style.setProperty(\"--caption-font-size-max\", sizeConfig.max);\n  document.documentElement.style.setProperty(\"--caption-font-size-min\", sizeConfig.min);\n  document.documentElement.style.setProperty(\"--caption-font-size-fullscreen\", sizeConfig.fullscreen);\n  document.documentElement.style.setProperty(\"--caption-font-size-fullscreen-max\", sizeConfig.fullscreenMax);\n\n  // Apply to element directly if it exists, using clamp for responsiveness\n  if (subtitleText) {\n    subtitleText.style.fontSize = `clamp(${sizeConfig.min}, ${sizeConfig.base}, ${sizeConfig.max})`;\n  }\n}\n\n/**\n * Update subtitles based on the current video time\n * @param {Array} currentSubtitles - Array of subtitle objects\n */\nfunction updateSubtitlesInternal(currentSubtitles) {\n  if (!videoPlayer || !subtitleText || !subtitleContainer) {\n    return;\n  }\n\n  if (isNaN(videoPlayer.currentTime)) return;\n\n  const currentTime = videoPlayer.currentTime * 1000; // Convert to ms\n  let foundSubtitle = null;\n\n  for (const subtitle of currentSubtitles) {\n    if (currentTime >= subtitle.startTime && currentTime <= subtitle.endTime) {\n      foundSubtitle = subtitle;\n      break;\n    }\n  }\n\n  if (foundSubtitle) {\n    if (subtitleText.textContent !== foundSubtitle.text) {\n      subtitleText.textContent = foundSubtitle.text;\n    }\n    subtitleContainer.style.display = \"block\";\n  } else {\n    hideCurrentSubtitle();\n  }\n}\n\n/**\n * Start displaying subtitles\n * @param {Array} currentSubtitles - Array of subtitle objects\n */\nexport function startSubtitleDisplay(currentSubtitles) {\n  if (!videoPlayer || !subtitleContainer) {\n    logWarn(\"Cannot start subtitle display: Player or container missing.\");\n    return;\n  }\n\n  stopSubtitleDisplay();\n\n  debugLog(\"Starting subtitle display interval.\");\n  \n  // Create a bound function to hold the subtitles closure\n  const updateFn = () => updateSubtitlesInternal(currentSubtitles);\n  \n  checkInterval = setInterval(updateFn, TIMING.SUBTITLE_UPDATE_INTERVAL_MS);\n\n  videoPlayer.addEventListener(\"play\", updateFn);\n  videoPlayer.addEventListener(\"seeked\", updateFn);\n  \n  // Store the function reference on the element to remove it later if needed\n  videoPlayer._subtitleUpdateFn = updateFn;\n}\n\n/**\n * Stop displaying subtitles\n */\nexport function stopSubtitleDisplay() {\n  if (checkInterval) {\n    clearInterval(checkInterval);\n    checkInterval = null;\n    debugLog(\"Stopped subtitle display interval.\");\n  }\n  if (videoPlayer && videoPlayer._subtitleUpdateFn) {\n    videoPlayer.removeEventListener(\"play\", videoPlayer._subtitleUpdateFn);\n    videoPlayer.removeEventListener(\"seeked\", videoPlayer._subtitleUpdateFn);\n    delete videoPlayer._subtitleUpdateFn;\n  }\n}\n\n/**\n * Hide the current subtitle\n */\nexport function hideCurrentSubtitle() {\n  if (subtitleContainer) {\n    subtitleContainer.style.display = \"none\";\n  }\n  if (subtitleText) {\n    subtitleText.textContent = \"\";\n  }\n}\n\nexport function clearRenderer() {\n  stopSubtitleDisplay();\n  hideCurrentSubtitle();\n}\n\n", "/**\n * Content Script for Better YouTube Caption Extension\n * Handles subtitle display, auto-generation, and communication with background script\n */\n\nimport {\n    DEFAULTS,\n    MESSAGE_ACTIONS,\n    STORAGE_KEYS,\n    TIMING,\n} from \"./constants.js\";\nimport { extractVideoId } from \"./url.js\";\nimport {\n    clearAutoGenerationTrigger,\n    scheduleAutoGeneration,\n    validateAutoGenerationConditions,\n} from \"./utils/autoGeneration.js\";\nimport { isContextInvalidated, isExtensionContextValid } from \"./utils/contextValidation.js\";\nimport { log as debugLog, error as logError, warn as logWarn } from \"./utils/logger.js\";\nimport {\n    applyCaptionFontSize,\n    clearRenderer,\n    createSubtitleElements,\n    findVideoElements,\n    startSubtitleDisplay,\n    stopSubtitleDisplay,\n} from \"./utils/subtitleRenderer.js\";\n\n// Global state\nlet currentSubtitles = [];\nlet initAttempts = 0;\nlet currentUrl = window.location.href;\nlet showSubtitlesEnabled = true; // Whether subtitles should be displayed\nlet urlObserver = null; // MutationObserver for URL changes\n\n/**\n * Get refiner model selection from storage result\n * Priority: custom model > recommended model > default\n * @param {Object} result - Storage result object\n * @returns {string} Selected model\n */\nfunction getRefinerModelSelection(result) {\n  const customModel = result[STORAGE_KEYS.REFINER_CUSTOM_MODEL]?.trim();\n  const recommendedModel = result[STORAGE_KEYS.REFINER_RECOMMENDED_MODEL]?.trim();\n  return (\n    (customModel && customModel.length > 0 ? customModel : null) ||\n    (recommendedModel && recommendedModel.length > 0 ? recommendedModel : null) ||\n    DEFAULTS.MODEL_REFINER\n  );\n}\n\n/**\n * Check if auto-generation should be triggered and trigger it if conditions are met\n * @param {string} videoId - Video ID\n * @param {Object} storageResult - Storage result with API keys and settings\n * @param {boolean} checkCaptionsEnabled - Whether to check if captions are enabled\n * @param {boolean} withDelay - Whether to add a delay before triggering (for initial page load)\n */\nfunction checkAndTriggerAutoGeneration(videoId, storageResult, checkCaptionsEnabled = true, withDelay = false) {\n  const validation = validateAutoGenerationConditions(\n    videoId,\n    storageResult,\n    showSubtitlesEnabled,\n    checkCaptionsEnabled\n  );\n\n  if (!validation.isValid) {\n    return false;\n  }\n\n  const modelSelection = getRefinerModelSelection(storageResult);\n  const triggerFn = () => {\n    triggerAutoGeneration(\n      videoId,\n      storageResult[STORAGE_KEYS.SCRAPE_CREATORS_API_KEY],\n      storageResult[STORAGE_KEYS.OPENROUTER_API_KEY],\n      modelSelection\n    );\n  };\n\n  scheduleAutoGeneration(videoId, storageResult, triggerFn, checkCaptionsEnabled, withDelay);\n  return true;\n}\n\n/**\n * Load stored subtitles for the current video from local storage\n * Also checks for auto-generation setting and triggers generation if enabled\n */\nfunction loadStoredSubtitles() {\n  try {\n    if (!isExtensionContextValid()) {\n      logWarn(\"Extension context invalidated, skipping subtitle load.\");\n      return;\n    }\n\n    // Only proceed if we're on a YouTube video page\n    if (!window.location.href.includes(\"youtube.com/watch\")) {\n      debugLog(\"Not on a video page, skipping subtitle load.\");\n      return;\n    }\n\n    const videoId = extractVideoId(window.location.href);\n    if (!videoId) {\n      logWarn(\"Could not extract video ID, skipping subtitle load.\");\n      return;\n    }\n\n    const keysToFetch = [\n      videoId,\n      STORAGE_KEYS.AUTO_GENERATE,\n      STORAGE_KEYS.SCRAPE_CREATORS_API_KEY,\n      STORAGE_KEYS.OPENROUTER_API_KEY,\n      STORAGE_KEYS.REFINER_RECOMMENDED_MODEL,\n      STORAGE_KEYS.REFINER_CUSTOM_MODEL,\n      STORAGE_KEYS.SHOW_SUBTITLES,\n    ];\n\n    chrome.storage.local.get(keysToFetch, (result) => {\n      try {\n        if (chrome.runtime.lastError) {\n          if (isContextInvalidated(chrome.runtime.lastError)) {\n            debugLog(\"Subtitle load aborted - extension context invalidated.\");\n            return;\n          }\n          logError(\"Error loading subtitles from storage:\", chrome.runtime.lastError.message);\n          return;\n        }\n\n        // Update show subtitles setting\n        showSubtitlesEnabled = result[STORAGE_KEYS.SHOW_SUBTITLES] !== false;\n\n        if (result && result[videoId]) {\n          debugLog(\"Found stored subtitles for this video.\");\n          currentSubtitles = result[videoId];\n          if (showSubtitlesEnabled) {\n            startSubtitleDisplay(currentSubtitles);\n          }\n        } else {\n          debugLog(\"No stored subtitles found for this video.\");\n          // Try to trigger auto-generation if conditions are met\n          checkAndTriggerAutoGeneration(videoId, result, true, true);\n        }\n      } catch (error) {\n        logError(\"Error processing stored subtitles:\", error);\n      }\n    });\n  } catch (error) {\n    if (error?.message?.includes(\"Extension context invalidated\")) {\n      debugLog(\"Subtitle load aborted - extension context invalidated (outer).\");\n      return;\n    }\n    logError(\"Error in loadStoredSubtitles:\", error);\n  }\n}\n\n/**\n * Trigger automatic subtitle generation\n * @param {string} videoId - Video ID\n * @param {string} scrapeCreatorsApiKey - Scrape Creators API key\n * @param {string} openRouterApiKey - OpenRouter API key\n * @param {string} modelSelection - Model selection\n */\nfunction triggerAutoGeneration(videoId, scrapeCreatorsApiKey, openRouterApiKey, modelSelection) {\n  clearSubtitles();\n\n  debugLog(\"Sending fetchSubtitles message to background...\", {\n    action: MESSAGE_ACTIONS.FETCH_SUBTITLES,\n    videoId: videoId,\n    hasScrapeKey: !!scrapeCreatorsApiKey,\n    hasOpenRouterKey: !!openRouterApiKey,\n    modelSelection: modelSelection,\n  });\n\n  chrome.runtime.sendMessage(\n    {\n      action: MESSAGE_ACTIONS.FETCH_SUBTITLES,\n      videoId: videoId,\n      scrapeCreatorsApiKey: scrapeCreatorsApiKey,\n      openRouterApiKey: openRouterApiKey,\n      modelSelection: modelSelection,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        logError(\"Error triggering auto-generation:\", chrome.runtime.lastError.message);\n        clearAutoGenerationTrigger(videoId);\n      } else {\n        debugLog(\"Auto-generation triggered successfully, response:\", response);\n      }\n    }\n  );\n}\n\n/**\n * Monitor URL changes on YouTube (SPA behavior)\n */\nfunction monitorUrlChanges() {\n  // Disconnect existing observer if any\n  if (urlObserver) {\n    urlObserver.disconnect();\n    urlObserver = null;\n  }\n\n  urlObserver = new MutationObserver(() => {\n    // Stop monitoring if extension context is invalidated\n    if (!isExtensionContextValid()) {\n      if (urlObserver) {\n        urlObserver.disconnect();\n        urlObserver = null;\n      }\n      return;\n    }\n\n    if (currentUrl !== window.location.href) {\n      debugLog(\"URL changed (mutation).\");\n      const oldVideoId = extractVideoId(currentUrl);\n      currentUrl = window.location.href;\n      const newVideoId = extractVideoId(currentUrl);\n\n      // If video ID changed, clear the auto-generation tracking for the old video\n      if (oldVideoId !== newVideoId) {\n        clearAutoGenerationTrigger(oldVideoId);\n      }\n\n      onUrlChange();\n    }\n  });\n\n  urlObserver.observe(document.body, { childList: true, subtree: true });\n}\n\n/**\n * Handle actions when the URL changes\n */\nfunction onUrlChange() {\n  debugLog(\"Reinitializing for new video...\");\n  clearSubtitles();\n  initAttempts = 0;\n  initialize();\n}\n\n/**\n * Initialize the content script\n */\nfunction initialize() {\n  debugLog(\"Initializing content script...\");\n\n  // Only initialize on YouTube video pages\n  if (!window.location.href.includes(\"youtube.com/watch\")) {\n    debugLog(\"Not on a video page, skipping initialization.\");\n    return;\n  }\n\n  if (!findVideoElements()) {\n    initAttempts++;\n    if (initAttempts < TIMING.MAX_INIT_ATTEMPTS) {\n      debugLog(`Video player not found, retrying (${initAttempts}/${TIMING.MAX_INIT_ATTEMPTS})...`);\n      setTimeout(initialize, TIMING.INIT_RETRY_DELAY_MS);\n    } else {\n      logError(\"Video player or container not found after multiple attempts.\");\n    }\n    return;\n  }\n\n  debugLog(\"Video player found.\");\n\n  createSubtitleElements();\n  loadStoredSubtitles();\n  loadCaptionFontSize();\n  setupMessageListener();\n}\n\n/**\n * Setup message listener for content script\n */\nfunction setupMessageListener() {\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    if (message.action === MESSAGE_ACTIONS.GET_VIDEO_TITLE) {\n      handleGetVideoTitle(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.GENERATE_SUMMARY) {\n      handleGenerateSummary(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.GENERATE_SUBTITLES) {\n      handleGenerateSubtitles(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.SUBTITLES_GENERATED) {\n      handleSubtitlesGenerated(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.TOGGLE_SUBTITLES) {\n      handleToggleSubtitles(message, sendResponse);\n      return true;\n    } else if (message.action === MESSAGE_ACTIONS.UPDATE_CAPTION_FONT_SIZE) {\n      handleUpdateCaptionFontSize(message, sendResponse);\n      return true;\n    }\n  });\n}\n\n/**\n * Handle get video title request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleGetVideoTitle(message, sendResponse) {\n  const titleElement = document.querySelector(\"h1.ytd-watch-metadata yt-formatted-string\");\n  const title = titleElement ? titleElement.textContent : null;\n  sendResponse({ title: title });\n}\n\n/**\n * Handle generate summary request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleGenerateSummary(message, sendResponse) {\n  debugLog(\"Received generateSummary request\");\n\n  const videoId = message.videoId || extractVideoId(window.location.href);\n\n  if (!videoId) {\n    sendResponse({\n      status: \"error\",\n      message: \"Could not extract video ID from URL.\",\n    });\n    return;\n  }\n\n  debugLog(\"Requesting summary from background for video:\", videoId);\n\n  chrome.runtime.sendMessage(\n    {\n      action: MESSAGE_ACTIONS.GENERATE_SUMMARY,\n      videoId: videoId,\n      scrapeCreatorsApiKey: message.scrapeCreatorsApiKey,\n      openRouterApiKey: message.openRouterApiKey,\n      modelSelection: message.modelSelection,\n      targetLanguage: message.targetLanguage,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        logError(\"Error sending message to background:\", chrome.runtime.lastError);\n        sendResponse({\n          status: \"error\",\n          message: \"Could not communicate with background script.\",\n        });\n      } else {\n        debugLog(\"Summary request sent to background, response:\", response);\n      }\n    }\n  );\n\n  sendResponse({ status: \"started\" });\n}\n\n/**\n * Handle generate subtitles request\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleGenerateSubtitles(message, sendResponse) {\n  debugLog(\"Received generateSubtitles request\");\n\n  const videoId = message.videoId || extractVideoId(window.location.href);\n\n  if (!videoId) {\n    sendResponse({\n      status: \"error\",\n      message: \"Could not extract video ID from URL.\",\n    });\n    return;\n  }\n\n  debugLog(\"Sending video ID to background:\", videoId);\n\n  clearSubtitles();\n\n  chrome.runtime.sendMessage(\n    {\n      action: MESSAGE_ACTIONS.FETCH_SUBTITLES,\n      videoId: videoId,\n      scrapeCreatorsApiKey: message.scrapeCreatorsApiKey,\n      openRouterApiKey: message.openRouterApiKey,\n      modelSelection: message.modelSelection,\n      forceRegenerate: message.forceRegenerate === true,\n    },\n    (response) => {\n      if (chrome.runtime.lastError) {\n        logError(\"Error sending message to background:\", chrome.runtime.lastError);\n        sendResponse({\n          status: \"error\",\n          message: \"Could not communicate with background script.\",\n        });\n      } else {\n        debugLog(\"Message sent to background, response:\", response);\n        if (response?.status === \"error\") {\n          clearAutoGenerationTrigger(videoId);\n        }\n      }\n    }\n  );\n\n  sendResponse({ status: \"started\" });\n}\n\n/**\n * Handle subtitles generated message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleSubtitlesGenerated(message, sendResponse) {\n  debugLog(\"Received subtitlesGenerated request\");\n  currentSubtitles = message.subtitles || [];\n  debugLog(`Received ${currentSubtitles.length} subtitle entries.`);\n\n  if (currentSubtitles.length > 0) {\n    if (showSubtitlesEnabled) {\n      startSubtitleDisplay(currentSubtitles);\n    }\n\n    // Store the subtitles locally\n    const videoId = message.videoId || extractVideoId(window.location.href);\n\n    if (videoId) {\n      chrome.storage.local.set({ [videoId]: currentSubtitles }, () => {\n        if (chrome.runtime.lastError) {\n          if (chrome.runtime.lastError.message && chrome.runtime.lastError.message.includes(\"QUOTA\")) {\n            logWarn(\"Storage quota exceeded. Transcript will not be saved, but subtitles will still display.\");\n          } else {\n            logError(\"Error saving subtitles:\", chrome.runtime.lastError.message);\n          }\n        } else {\n          debugLog(\"Subtitles saved to local storage for video ID:\", videoId);\n        }\n      });\n    } else {\n      logWarn(\"Could not extract video ID, subtitles not saved.\");\n    }\n\n    sendResponse({ status: \"success\" });\n  } else {\n    logWarn(\"Received empty subtitles array.\");\n    clearSubtitles();\n    sendResponse({ status: \"no_subtitles_found\" });\n  }\n}\n\n/**\n * Load and apply caption font size from storage\n */\nfunction loadCaptionFontSize() {\n  try {\n    if (!isExtensionContextValid()) {\n      debugLog(\"Context invalidated, skipping font size load.\");\n      return;\n    }\n\n    chrome.storage.local.get([STORAGE_KEYS.CAPTION_FONT_SIZE], (result) => {\n      try {\n        if (chrome.runtime.lastError) {\n          const errorMsg = chrome.runtime.lastError.message || \"\";\n          if (isContextInvalidated(chrome.runtime.lastError)) {\n            debugLog(\"Font size load aborted - extension context invalidated.\");\n            return;\n          }\n          logWarn(\"Error loading caption font size:\", errorMsg);\n          return;\n        }\n\n        const fontSize = result?.[STORAGE_KEYS.CAPTION_FONT_SIZE] || DEFAULTS.CAPTION_FONT_SIZE;\n        applyCaptionFontSize(fontSize);\n      } catch (error) {\n        if (error?.message?.includes(\"Extension context invalidated\")) {\n          debugLog(\"Font size load aborted (callback) - extension context invalidated.\");\n          return;\n        }\n        logError(\"Error applying caption font size:\", error);\n      }\n    });\n  } catch (error) {\n    if (error?.message?.includes(\"Extension context invalidated\")) {\n      debugLog(\"Font size load aborted (outer) - extension context invalidated.\");\n      return;\n    }\n    logError(\"Error in loadCaptionFontSize:\", error);\n  }\n}\n\n/**\n * Handle update caption font size message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleUpdateCaptionFontSize(message, sendResponse) {\n  const fontSize = message.fontSize || DEFAULTS.CAPTION_FONT_SIZE;\n  applyCaptionFontSize(fontSize);\n  sendResponse({ status: \"success\" });\n}\n\n/**\n * Handle toggle subtitles message\n * @param {Object} message - Message object\n * @param {Function} sendResponse - Response callback\n */\nfunction handleToggleSubtitles(message, sendResponse) {\n  debugLog(\"Received toggleSubtitles request\");\n  const hasShowSubtitles = Object.prototype.hasOwnProperty.call(message, \"showSubtitles\");\n  const hasEnabled = Object.prototype.hasOwnProperty.call(message, \"enabled\");\n  const nextState = hasShowSubtitles\n    ? message.showSubtitles !== false\n    : hasEnabled\n    ? message.enabled !== false\n    : true;\n  const wasEnabled = showSubtitlesEnabled;\n  showSubtitlesEnabled = nextState;\n  chrome.storage.local.set({ [STORAGE_KEYS.SHOW_SUBTITLES]: showSubtitlesEnabled });\n\n  if (showSubtitlesEnabled && currentSubtitles.length > 0) {\n    startSubtitleDisplay(currentSubtitles);\n  } else {\n    stopSubtitleDisplay();\n    clearRenderer();\n  }\n\n  // If captions were just turned on and there are no subtitles, check for auto-generation\n  if (showSubtitlesEnabled && !wasEnabled && currentSubtitles.length === 0) {\n    const videoId = extractVideoId(window.location.href);\n    if (videoId) {\n      chrome.storage.local.get(\n        [\n          videoId,\n          STORAGE_KEYS.AUTO_GENERATE,\n          STORAGE_KEYS.SCRAPE_CREATORS_API_KEY,\n          STORAGE_KEYS.OPENROUTER_API_KEY,\n          STORAGE_KEYS.REFINER_RECOMMENDED_MODEL,\n          STORAGE_KEYS.REFINER_CUSTOM_MODEL,\n        ],\n        (result) => {\n          // Check if subtitles already exist for this video\n          if (result[videoId] && result[videoId].length > 0) {\n            debugLog(\"Subtitles already exist for this video, loading them...\");\n            currentSubtitles = result[videoId];\n            startSubtitleDisplay(currentSubtitles);\n            return;\n          }\n\n          // Try to trigger auto-generation (no delay, captions already enabled)\n          checkAndTriggerAutoGeneration(videoId, result, false, false);\n        }\n      );\n    }\n  }\n\n  sendResponse({ status: \"success\" });\n}\n\n/**\n * Clear subtitles and stop display\n */\nfunction clearSubtitles() {\n  currentSubtitles = [];\n  clearRenderer();\n  debugLog(\"Subtitles cleared.\");\n}\n\n// Initialize immediately since we're using document_end in manifest\n(function () {\n  debugLog(\"Content script loaded, readyState:\", document.readyState);\n\n  const startInitialization = () => {\n    initialize();\n    monitorUrlChanges();\n  };\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", startInitialization);\n  } else {\n    // Give YouTube a moment to render if we're already loaded\n    setTimeout(startInitialization, TIMING.CONTENT_SCRIPT_INIT_DELAY_MS);\n  }\n})();\n"],
  "mappings": "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",
  "names": ["STORAGE_KEYS", "TIMING", "STORAGE", "DEFAULTS", "FONT_SIZES", "YOUTUBE", "MESSAGE_ACTIONS", "ELEMENT_IDS", "extractVideoId", "url", "e", "isExtensionContextValid", "isContextInvalidated", "lastError", "PREFIX", "DEBUG", "log", "args", "warn", "error", "autoGenerationTriggered", "isAutoGenerationTriggered", "videoId", "markAutoGenerationTriggered", "clearAutoGenerationTrigger", "validateAutoGenerationConditions", "storageResult", "showSubtitlesEnabled", "checkCaptionsEnabled", "STORAGE_KEYS", "log", "verifyVideoIdUnchanged", "originalVideoId", "currentVideoId", "extractVideoId", "verifyCaptionsStillEnabled", "resolve", "checkResult", "executeAutoGenerationTrigger", "triggerFn", "scheduleAutoGeneration", "withDelay", "executeTrigger", "isExtensionContextValid", "TIMING", "subtitleContainer", "subtitleText", "videoPlayer", "videoContainer", "checkInterval", "findVideoElements", "YOUTUBE", "createSubtitleElements", "ELEMENT_IDS", "log", "error", "applyCaptionFontSize", "size", "sizeConfig", "FONT_SIZES", "updateSubtitlesInternal", "currentSubtitles", "currentTime", "foundSubtitle", "subtitle", "hideCurrentSubtitle", "startSubtitleDisplay", "warn", "stopSubtitleDisplay", "updateFn", "TIMING", "clearRenderer", "currentSubtitles", "initAttempts", "currentUrl", "showSubtitlesEnabled", "urlObserver", "getRefinerModelSelection", "result", "customModel", "STORAGE_KEYS", "recommendedModel", "DEFAULTS", "checkAndTriggerAutoGeneration", "videoId", "storageResult", "checkCaptionsEnabled", "withDelay", "validateAutoGenerationConditions", "modelSelection", "scheduleAutoGeneration", "triggerAutoGeneration", "loadStoredSubtitles", "isExtensionContextValid", "warn", "log", "extractVideoId", "keysToFetch", "isContextInvalidated", "error", "startSubtitleDisplay", "scrapeCreatorsApiKey", "openRouterApiKey", "clearSubtitles", "MESSAGE_ACTIONS", "response", "clearAutoGenerationTrigger", "monitorUrlChanges", "oldVideoId", "newVideoId", "onUrlChange", "initialize", "findVideoElements", "TIMING", "createSubtitleElements", "loadCaptionFontSize", "setupMessageListener", "message", "sender", "sendResponse", "handleGetVideoTitle", "handleGenerateSummary", "handleGenerateSubtitles", "handleSubtitlesGenerated", "handleToggleSubtitles", "handleUpdateCaptionFontSize", "titleElement", "title", "errorMsg", "fontSize", "applyCaptionFontSize", "hasShowSubtitles", "hasEnabled", "nextState", "wasEnabled", "stopSubtitleDisplay", "clearRenderer", "startInitialization"]
}
